program EssMiner;
{$define SMART}
{$i srl/srl.scar}
{$i Reflection/Reflection.simba}
{$i SRL\SRL\Misc\stats.simba}

type
  TTilesArray = array of TTile;
var
  EssCountStart, Price : integer;
const
  RUNEESS_ID = 1436;
  PUREESS_ID   = 7936;

Procedure DeclarePlayers;
begin
  HowManyPlayers := 1;
  NumberOfPlayers(HowManyPlayers);
  CurrentPlayer := 0;

    with players[0] do
  begin
    Name := '';
    Pass := '';
    Active := True;
    Pin := ''; //Leave blank if no pin
    Loc := 'at bank'; //Read the thread to see valid arguments.
    Integers[4]:= 10; //Amount of loads you want to do.
  end;
end;

function ConvertPrice(input: string): Integer;     // Credit to BlumbleBee for these two functions <3
var
  f: Extended;
begin
  input := Replace(Lowercase(Trim(input)), ',', '');
  if (Pos('m', input) > 0) then
    f := StrToFloatDef(Copy(input, 1, Pos('m', input) - 1), 0) * 1000000
  else if (Pos('k', input) > 0) then
    f := StrToFloatDef(Copy(input, 1, Pos('k', input) - 1), 0) * 1000
  else
    f := StrToFloatDef(Input, 0);
  Result := Round(f);
end;

procedure SetPrice(runeEss: Boolean);
var
  S: string;
  I: Integer;
begin
  if runeEss = true then
    I := RUNEESS_ID
  else
    I := PUREESS_ID;

  s := getPage('http://services.runescape.com/m=itemdb_rs/Rune_essence/viewitem.ws?obj='+IntToStr(I));
  Price := ConvertPrice(Between('<b>Market price:</b> ', #10 + '</span>', s));
end;

Procedure AxeWielded;
var
Equipped : integer;
TheIDs: TIntegerArray;
Pickaxe : TInvItemArray;
Begin
  If Not (LoggedIn) Or Not (Players[CurrentPlayer].Active) Then
    exit;
  TheIDs := [1265, 1271, 15259, 1267, 1273, 1275, 1269];
  GameTab(tab_Inv);
  Wait(500 + Random(200));
  if(R_ItemIDExistsEx(TheIDs, Pickaxe))then
    begin
      Players[CurrentPlayer].Booleans[0] := False;
      Writeln('Pickaxe is in inventory.');
      Exit;
    end else
      GameTab(tab_Equip);
      Wait(500 + Random(200));
      Equipped := GetEquippedIDAt(3);
      if(InIntArray(TheIDs, Equipped))then
        begin
          Players[CurrentPlayer].Booleans[0] := True;
          Writeln('Hatchet is equipped.');
          Exit;
        end;
End;

Procedure LevelTalking;
Begin
     If Not (LoggedIn) Or Not (Players[CurrentPlayer].Active) Then
          exit;
     If (FindBlackChatMessage('Congratulations')) Or
          (FindBlackChatMessage('you just advance')) Or
          InChat('Congratulations') Or InChat('just advance') Or
               InChat('congratulations,') Then
          Begin
               Inc(Players[CurrentPlayer].Integers[2]);
               stats_IncVariable('Total Levels Gained', 1);
               Writeln('Woooot we have now gained'+IntToStr(Players[CurrentPlayer].Integers[2])+' levels!');
               Begin
                    Case Random(10) Of
                         0: TypeSend('Guess what... I levelled!');
                         1: TypeSend('w00t lvld');
                         2: TypeSend('lvld again...');
                         3: TypeSend('grats me! I lvld!');
                         4: TypeSend('gay lag, didnt realise i lvld');
                         5: TypeSend('woopdewoop');
                         6: TypeSend('this levelling stuff is getting boring...');
                         7: TypeSend('dangdarnit, I jooost lavallled');
                         8: TypeSend('can we have a party cause i just lvld');
                         9: TypeSend('house party at mine! jokes...');
                    End;
               End;
          End;
End;

procedure PrintOnSmart(TP: TStringArray; Placement: TPoint; Colour, Shadow: integer);
var
 mx, my, Pic, I, B, H, TPH, Numb: Integer;
 TTP: TPointArray;
 Canvas: TCanvas;
begin
  SmartSetDebug(True);
  GetClientDimensions(mx,my);
  Pic := BitmapFromString(mx,my,'');
  TPH := High(TP);
  for I := 0 to TPH do
  begin
    TTP := LoadTextTPA(TP[i], SmallChars, H);
    for B := 0 to High(TTP) do
    begin
      Numb := ((I + 1) * 13);
      FastSetPixel(Pic, TTP[b].x + 1, TTP[b].y + Numb + 1, Shadow);
      FastSetPixel(Pic, TTP[b].x, TTP[b].y + Numb, Colour);
    end;
  end;
  Canvas := TCANVAS.Create;
  Canvas.Handle := SmartGetDebugDC;
  DrawBitmap(Pic, Canvas, Placement.x, Placement.y);
  FreeBitmap(Pic);
end;

Procedure ProgressReport;
var
  EssMined, TotalLoads, TotalLevels, TotalAntiban, I, ActivePlayers: Integer;
Begin
    LevelTalking;
    for I := 0 to HowManyPlayers-1 do
      begin
        with Players[I] do
        begin
          if Active then
            Inc(ActivePlayers);
          EssMined := EssMined + Integers[0];
          TotalLoads := TotalLoads + Integers[1];
          TotalLevels := TotalLevels + Integers[2];
          TotalAntiban := TotalAntiban + Integers[3];
        end;
      end;
      PrintOnSmart(['  Boom Goes The Willows'],Point(22, 30), 62207, 131072);
      PrintOnSmart(
      ['',
      '',
      '',
      '            Global Stats ',
      '           --------------',
       '          Time Running: '+ TimeRunning,
       '          Mined: '+IntToStr(EssMined)+' Essence',
       '          Loads Done: : '+IntToStr(TotalLoads),
       '          Gained: '+IntToStr(Price*EssMined)+' gp',
       '          Gained: '+IntToStr(TotalLevels)+' levels',
       '          Players Active: '+IntToStr(ActivePlayers),
       '          ',
       '            Player Stats ',
       '           --------------',
        '          Player: '+Capitalize(Players[CurrentPlayer].Name),
        '          Essence: ' + IntToStr(Players[CurrentPlayer].Integers[0]),
        '          Gained: '+IntToStr(Price*Players[CurrentPlayer].Integers[0])+' gp'
     ], Point(30, 60), 1959605, 131072);

    cleardebug;
    Writeln('[-----------------------------]');
    Writeln('[         Essence Miner       ]');
    Writeln('[-----------------------------]');
    Writeln(' We worked for ' + TimeRunning);
    Writeln(' Mined ' + IntToStr(EssMined)+' Essence');
    Writeln(' Loads Done: ' + IntToStr(TotalLoads));
    writeLn(' Gained: '+IntToStr(Price*EssMined)+' gp');
    Writeln(' Gained: ' + IntToStr(TotalLevels)+' levels');
    Writeln(' Antibanned ' + IntToStr(TotalAntiBan));
    Writeln('[-----------------------------]');
    Stats_Commit;
End;

procedure AntiBan;
begin
  case (Random(400)) of
    0: RandomRClick;
    1: MouseSpeed := 15 + Random(5);
    2: PickUpMouse;
    3: BoredHuman;
    4..400: begin
      Wait(100 + Random(50));
      Exit;
    end;
  end;
  Inc(Players[CurrentPlayer].Integers[3]);
end;

Procedure AntiRandoms;
Begin
    If Not (LoggedIn) Or Not (Players[CurrentPlayer].Active) Then
        NextPlayer(false);
        LevelTalking;
    FindNormalRandoms;
    Wait(300+Random(200));
    FindLamp('Mining');
End;

Function WalkToAubury: Boolean;
Begin
  If Not LoggedIn Then
    Exit;
  EssCountStart := R_InvCount;
  If WalkToTile(Point(3257, 3409), 2, 1) Then
    If not WalkToTile(Point(3253, 3401), 1, 0) Then
      Exit;
  Result := True;
End;

Function FindEss(Var X, Y : Integer; W, H, X1, Y1, X2, Y2 : Integer): Boolean;
Var
  i : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
begin
  if not LoggedIn then Exit;
  ColorToleranceSpeed(2);
  SetColorSpeed2Modifiers(0.00, 1.17);
  begin
    Writeln('beginning FindEss');
    FindColorsSpiralTolerance(x, y, TPA, 13224412, MSX1, MSY1, MSX2, MSY2, 6);
    SetColorToleranceSpeed(1);
    ATPA := SplitTPAEx(TPA, 40, 40);
    if (Length(ATPA) = 0) then
      Exit;
    SortATPAFromFirstPoint(ATPA, Point(MSCX, MSCY));
    h := High(ATPA);
    for i := 0 to h do
    begin;
      MiddleTPAEx(ATPA[i], x, y);
      MMouse(x, y, 3, 3);
      if WaitUpText('une', 450) then begin
        Result := True;
        break;
      end;
    end;
    Writeln('Found the essence!');
  End;
End;

Function FoundEss(Var X, Y : Integer): Boolean;
Begin
  Writeln('Beginning FoundEss');
  Result := FindEss(X, Y, 35, 35, MSX1, MSY1, MSX2, MSY2);
End;


Function MiningCheck:Boolean;
Begin
  if not LoggedIn then Exit;
  if CharacterAnimating then
    Wait(1000);
      if CharacterAnimating then
  Result := True;
End;

Function DoPortal:boolean;
var
  NWPortalTile, SWPortalTile, SEPortalTile, NEPortalTile : TTile;
  M : TPoint;
  x, y : integer;
Begin
  NWPortalTile := (tile(2885, 4850)); //NW
  SWPortalTile := (tile(2889, 4813)); //SW
  SEPortalTile := (tile(2933, 4815)); //SE
  NEPortalTile := (tile(2932, 4854)); //NE

  case Players[CurrentPlayer].Loc of
  'NW' : Begin
          if not WalkToTile((NWPortalTile), 1, 1) then begin
          NextPlayer(False);
          Exit;
         end else
         begin
          if TileOnMS(NWPortalTile, 0) then
            begin
              M := TileToMSEx(NWPortalTile, 0.5, 0.5, 0);
              MMouse(M.x, M.y, 1, 1);
              GetMousePos(x, y);
              if WaitUpTextMulti(['Por', 'tal', 'ter'], 500) then
                Mouse(x, y, 0, 0, True);
              Result := True;
            end;
          end;
         End;
  'SW' : Begin
          if not WalkToTile((SWPortalTile), 1, 1) then begin
          NextPlayer(False);
          Exit;
         end else
         begin
          if TileOnMS(SWPortalTile, 0) then
            begin
              M := TileToMSEx(SWPortalTile, 0.5, 0.5, 0);
              MMouse(M.x, M.y, 1, 1);
              GetMousePos(x, y);
              if WaitUpTextMulti(['Por', 'tal', 'ter'], 500) then
                Mouse(x, y, 0, 0, True);
              Result := True;
            end;
          end;
         End;
  'SE' : Begin
          if not WalkToTile((SEPortalTile), 1, 1) then begin
          NextPlayer(False);
          exit;
         end else
         begin
          if TileOnMS(SEPortalTile, 0) then
            begin
              M := TileToMSEx(SEPortalTile, 0.5, 0.5, 0);
              MMouse(M.x, M.y, 1, 1);
              GetMousePos(x, y);
              if WaitUpTextMulti(['Por', 'tal', 'ter'], 500) then
                Mouse(x, y, 0, 0, True);
              Result := True;
            end;
          end;
         end;
  'NE' : Begin
          if not WalkToTile((NEPortalTile), 1, 1) then begin
          NextPlayer(False);
          exit;
         end else
         begin
          if TileOnMS(NEPortalTile, 0) then
            begin
              M := TileToMSEx(NEPortalTile, 0.5, 0.5, 0);
              MMouse(M.x, M.y, 1, 1);
              GetMousePos(x, y);
              if WaitUpTextMulti(['Por', 'tal', 'ter'], 500) then
                Mouse(x, y, 0, 0, True);
              Result := True;
            end;
          end;
         end;
  End;
end;

Function BoomEss: Boolean;
Var
  X, Y, Tried : Integer;
Begin
  if Not LoggedIn then
    Exit;
  Repeat
    if Tried = 10 then
    begin
      Writeln('Cant find ess... Exiting');
      Exit;
    end;
    if not FoundEss(X, Y) then
    Begin
      Inc(Tried);
      Wait(2000 + Random(500));
      Continue;
    End;
    Mouse(X, Y, 0, 0, True);
    Wait(1500 + Random(500));
    Repeat
      LevelTalking;
      if MiningCheck then
        begin
        Antiban
        AntiRandoms
        end;
      if InvFull then
        Break;
    Until not (MiningCheck);
  Until InvFull;
  Result := True;
End;

Function DoAubury:Boolean;
var
Aubury:TNPC;
APoint : TPoint;
x, y :integer;
Begin
  if not LoggedIn then Exit;
  if FindNPC(553, Aubury) then
    APoint := TileToMSEx(Aubury.Tile, 0.5, 0.5, Aubury.Height);
    MMouse(APoint.x, APoint.y, 1, 1);
    if WaitUpText('-to', 600) then
      Mouse(APoint.x, APoint.y, 1, 1, False);
    if not R_ChooseOption('elep') then
        Exit;
    While not FindColorTolerance(x, y, 9358049, MSX1, MSY1, MSX2, MSY2, 5) do
      Wait(100);
    Result := True;
End;

function DistanceFromArray(TheTiles: TTilesArray): integer;
var
  MyPos: TTile;
  I: integer;
begin
  MyPos := GetMyPos;
  Result := High(Result);
  for I := 0 to High(TheTiles) do
    Result := Min(Result, Distance(MyPos.x, MyPos.y, TheTiles[I].X, TheTiles[I].Y));
end;

Function AtEssPlace:Boolean;
var
  EssPlaceTiles : array of TTile;
Begin
  if not LoggedIn then Exit;
  EssPlaceTiles := [tile(2892, 4848),  //NW
                    tile(2926, 4849),  //NE
                    tile(2929, 4816),  //SE
                    tile(2895, 4814)]  //SW

  if DistanceFromArray(EssPlaceTiles) < 10 then
  begin
    Result := True;
    Writeln('Result = true atessplace...');
  end else
  begin
    Result := False;
    Exit;
  end;
End;

Function WhichEssPlace:boolean;   // I know I can do case, will do later.
Begin
  if DistanceFrom(tile(2892, 4848)) < 12 then begin
    Players[CurrentPlayer].Loc := 'NE';
    if BoomEss then
       if DoPortal then
          Result := True;
      Exit;
    End;
  if DistanceFrom(tile(2926, 4849)) < 12 then begin
      Players[CurrentPlayer].Loc := 'NE';
      if BoomEss then
       if DoPortal then
      Result := True;
      Exit;
    End;
  if DistanceFrom(tile(2929, 4816)) < 12 then begin
      Players[CurrentPlayer].Loc := 'SE';
      if BoomEss then
       if DoPortal then
      Result := True;
      Exit;
    End;
  if DistanceFrom(tile(2895, 4814)) < 12 then begin
      Players[CurrentPlayer].Loc := 'SW';
      if BoomEss then
       if DoPortal then
      Result := True;
      Exit;
    End;
End;

Function AtMiddle:boolean;
Begin
  if not LoggedIn then Exit;
  if DistanceFrom(tile(2911, 4831)) < 8 then begin
    Result := True;
  end else Result := false;
End;

Function WalkFromMiddle:boolean;
Begin
  if not LoggedIn then Exit;
  if not AtMiddle then
    Exit;
  If WalkToTile(Point(2905, 4840), 1, 1) then
    If WalkToTile(Point(2896, 4846), 1, 1) then
      Begin
        Result := True;
      End;
End;


Function WalkToBank: Boolean;
Begin
  If Not LoggedIn Then
    Exit;
  If WalkToTile(Point(3259, 3411), 1, 1) Then
    if WalkToTile(Point(3253, 3420), 1, 1) then
      Result := True;
End;

Function Bank: Boolean;
Var
i, EssCountEnd, EssCountFinal, ID : integer;
B : boolean;
Begin
  If Not LoggedIn Then
    Exit;
    Wait(1000+ Random(1000));
    ID := getItemIDAt(2);
  If Not OpenBankFast(Bank_VE) Then
    If Not OpenBankQuiet(Bank_VE) Then
      If Not R_OpenBankBooth('veb') then
      Exit;
     for i := 1 + Integer(not Players[CurrentPlayer].Booleans[0]) to 28 do
      begin
        Deposit(i, 28, True);
      end;
  Result := True;
  CloseBank;
  Inc(Players[CurrentPlayer].Integers[1]);
  stats_IncVariable('(Loads Done)', 1);
  EssCountFinal := (EssCountEnd - EssCountStart);
  begin
        B := ID = RUNEESS_ID;
        SetPrice(B);
        if B then
          stats_IncVariable('(Rune Essence (Mined))', EssCountFinal)
        else stats_IncVariable('(Pure Essence (Mined))', EssCountFinal);
  end;
  IncEx(Players[CurrentPlayer].Integers[0], EssCountFinal);
  ProgressReport;
End;

Procedure MainLoop;
Begin
  repeat
  Case Lowercase(Players[CurrentPlayer].Loc) of
    'banked':
    if WalkToAubury then
      Players[CurrentPlayer].Loc := 'at aubury';
    'at aubury':
    if DoAubury then
      Players[CurrentPlayer].Loc := 'done aubury';
    'done aubury': begin
    if AtMiddle then
      Players[CurrentPlayer].Loc := 'at middle';
    if not AtMiddle then
      Players[CurrentPlayer].Loc := 'nearly ess';
      end;
    'at middle':
    if WalkFromMiddle then
      Players[CurrentPlayer].Loc := 'nearly ess';
    'nearly ess':
    if AtEssPlace then
      Players[CurrentPlayer].Loc := 'at ess';
    'at ess': WhichEssPlace;
    'NW':
    if BoomEss then
      if DoPortal then
      Players[CurrentPlayer].Loc := 'teleported';
    'SW':
    if BoomEss then
      if DoPortal then
      Players[CurrentPlayer].Loc := 'teleported';
    'NE':
    if BoomEss then
      if DoPortal then
      Players[CurrentPlayer].Loc := 'teleported';
    'SE':
    if BoomEss then
      if DoPortal then
      Players[CurrentPlayer].Loc := 'teleported';
    'teleported':
    if WalkToBank then
      Players[CurrentPlayer].Loc := 'at bank';
    'at bank':
    if Bank then
      Players[CurrentPlayer].Loc := 'banked';
  end;
  until(Players[CurrentPlayer].Integers[1] >= Players[CurrentPlayer].Integers[4]);
End;



begin
    ClearDebug;
    ClearReport;
    Smart_Server := 17;
    Smart_Members := false;
    Smart_Signed := true;
    Smart_SuperDetail := false;
    SetupSRL;
    begin
        DeclarePlayers;
        LoginPlayer;
        ProgressReport;
        AxeWielded;
        MakeCompass('North');
        SetAngle(True);
        Gametab(tab_Inv);
  repeat
    MainLoop
  until AllPlayersInactive();
    end;
end.
